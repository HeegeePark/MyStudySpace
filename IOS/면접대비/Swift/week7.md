# MVC 구조에 대해 블록 그림을 그리고, 각 역할과 흐름을 설명하시오.

- 뷰는 사용자가 보는 결과 화면이고, 모델은 데이터를 가지고 있습니다. 컨트롤러는 뷰와 모델 사이에서 뷰에서의 사용자 입력을 처리하고, 그에 맞는 데이터를 모델에게 요청하여 뷰에 반영하고 사용자에 보여줍니다. 모델이 업데이트될 때도 그에 맞게 뷰를 갱신합니다.

---

## MVC

- 모델 = 데이터
- 뷰 = 사용자가 보는 결과 화면 
- 컨트롤러 = 사용자 입력 처리, 요청에 맞는 데이터를 모델에게 요청해서 그것을 뷰에 반영하여 사용자한테 보여줌.

BUT, ios는 view와 controller 분리가 어려움. 뷰컨트롤러가 거의 모든 일을 하게 됨.

![image](https://user-images.githubusercontent.com/47033052/222340055-a930f90d-12b0-46a7-91c4-0b1b44df9f82.png)

---

# Protocol Oriented Programming과 Object Oriented Programming의 차이점을 설명하시오.

- OOP의 핵심은 상속입니다. 상속을 통해 타입을 확장하는 수직 구조이고 IS-A 관계를 표현 할 수 있습니다. 이 과정에서 불필요한 메서드나 변수를 물려 받아야 한다는 단점이 있고 class에서만 상속이 가능합니다.

- POP는 수평구조 표현인 합성으로 객체를 묘사할 수 있게 도와줍니다. 합성을 통해 타입을 확장하고 HAS-A 관계로 표현됩니다. Protocol은 불필요한 메서드나 변수를 갖지 않게 할 수 있고 class 뿐만 아니라 struct, enum에서도 사용 가능합니다.

---

## 프로토콜

- 프로토콜(protocol)은 특정 역할을 수행하기 위한 메서드, 프로퍼티, 기타 요구사항 등의 청사진 정의
- 구조체, 클래스, 열거형은 프로토콜을 채택(Adopted)해서 특정 기능을 수행하기 위한 프로토콜의 요구사항을 실제로 구현할 수 있음.
- 어떤 프로토콜의 요구사항을 모두 따르는 타입은 그 프로토콜을 준수한다(conform)고 표현
- 타입에서 프로토콜의 요구사항을 충족시키려면 프로토콜이 제시하는 청사진의 기능을 모두 구현해야 함.
  - 즉, 프로토콜은 기능을 정의하고 제시할 뿐, 스스로 기능 구현 X

---

# Hashable이 무엇이고, Equatable을 왜 상속해야 하는가?

- `Hashable`은 프로토콜 중 하나로, `Hasher`에 의해 해시 값을 제공할 수 있는 타입입니다. 즉, 이 프로토콜을 채택한 타입은 유일한 값(해시값)으로 구분될 수 있어야 합니다.
- 그러나 두 객체의 해시값이 같다고 두 객체의 값이 같다고 보장할 수 없으므로, Hashable 프로토콜은 값의 비교가 가능함을 보장해주는 Equatable 프로토콜을 상속하여 객체가 같기 위한 연산자를 정의해주어야 합니다.

---

`Hashable`은 프로토콜 중 하나로, `Hasher`에 의해 해시 값을 제공할 수 있는 타입이다. 즉, 이 프로토콜을 채택한 타입은 유일한 값(해시값)으로 구분될 수 있어야 한다.

`Equatable`은 값의 비교가 가능함을 보장해주는 프로토콜입니다. 이 프로토콜을 채택한 타입들은 `==` 연산자나 `!=` 연산자를 사용해 값을 비교할 수 있다. 

(`Array`에서 `contains(_:)` 메소드를 사용할 수 있는 것도 `Array`가 `Equatable` 프로토콜을 채택하고 있기 때문이다.)

### Equatable을 상속하는 이유

어떤 객체가 `Hashable`하다는 것은 딕셔너리의 키 값으로 사용될 수 있다는 것, 즉 *구별될 수 있는 값* 이라는 뜻이다. 그렇다면 두 객체의 해시 값이 같다면 두 객체들은 같은 객체라고 할 수 있을까?

> `a == b`이면 `a.hashvalue == b.hashvalue` 은 참이다. 그러나 그 역은 성립하지 않는다.

객체의 해시값이 같다는 사실은 두 객체가 같다는 것을 보장해주지 않는다. 따라서 `Hashable` 프로토콜은 `Equatable` 프로토콜을 상속하여 객체가 같기 위한 연산자를 정의해주는 것이다.

https://devejs.github.io/ios/2020/10/07/swift-hashable.html

---

# mutating 키워드에 대해 설명하시오.

- mutating 키워드는 해당 메서드가 호출된다면 실제 복사를 해야한다고 알려주는 역할입니다.
- 값 타입인 struct와 enum은 인스턴스 메서드 내에서 수정이 불가하지만, 수정이 필요한 경우 `mutating` 을 붙여주면 수정할 수 있습니다. 또한 메서드는 self property에 새 인스턴스를 할당할 수도 있습니다.
- mutating을 선언한 메서드는 메서드 내에서 프로퍼티를 변경할 수 있고, 메서드가 종료될 때 변경한 모든 내용을 원래 struct에 다시 기록합니다.
- 하지만 let으로 선언한 인스턴스는 프로퍼티가 변수여도 속성을 변경할 수 없기 때문에 mutating 메서드를 호출할 수 없습니다.

---

## mutating

사전적 의미 - 변화시키다, 돌연변이

클래스는 reference 타입이고 `struct와 enum` 는 value type입니다.

값 타입의 속성은 기본적으로 인스턴스 메서드 내에서 수정할 수 없습니다.
만약 수정해야하는 경우 `mutating`을 붙여주면 됩니다.



mutating을 선언한 메서드는 메서드 내에서 프로퍼티를 변경할 수 있고, 메서드가 종료될 때 변경한 모든 내용을 원래 struct에 다시 기록합니다. 또한 메서드는 self property에 새 인스턴스를 할당할 수도 있습니다.



**mutating 키워드는 해당 메서드가 호출된다면 실제 복사를 해야한다고 알려주는 역할입니다.**

 **만약 let으로 선언된 인스턴스는 프로퍼티가 변수여도 속성을 변경할 수 없기 때문에 mutating 메서드를 호출할 수 없습니다.**

https://velog.io/@hayeon/mutating-%ED%82%A4%EC%9B%8C%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EC%8B%9C%EC%98%A4

https://velog.io/@wonhee010/mutating

---

# 탈출 클로저에 대하여 설명하시오.

- 클로저가 함수 인자로 전달되지만 함수 밖에서 즉, 함수가 반환된 후에 실행되는 클로저입니다. 함수가 끝난 후에도 메모리에 저장돼있어야 하는 특성 때문에, 클로저 안에서 사용된 self 등 outer object에 weak로 레퍼런스 타입을 약한 참조로 연결될 수 있도록 주의해야 합니다.
- 매개변수 앞에 @escaping 붙여 사용할 수 있고, 한 함수가 끝나고 다음 함수가 실행되도록 할 수 있는 비동기나 completionHandler에서 쓸 수 있습니다.

---

### escaping closure

- 클로저가 함수 인자로 전달되지만 함수 밖에서 (함수가 반환된 후에) 실행되는거
  - 함수가 끝난 후에도 메모리에 저장돼있어야 함
  - 이는 closure 안에서 사용된 outer object (self와 같은)에 weak와 같은 레퍼런스 타입을 사용해야 할 수 있음을 주의하도록 한다.
- 매개변수 앞에 @escaping 써야함
- 비동기나 completionHandler에서 쓸 수 있음
  - 한 함수 끝나고 다음 함수 실행되도록 순서 정할 수 있으니까

### closure

- 사용자의 **코드 안에서 전달되어 사용할 수 있는 로직**을 가진 중괄호 `{}`로 구분된 **코드 블럭**

---

# Extension에 대해 설명하시오.

- 익스텐션은 구조체, 클래스, 열거형, 프로토콜 타입에 새로운 기능을 추가할 수 있는 문법으로, 기능을 추가하려는 타입의 구현된 소스 코드를 알지 못하거나 볼 수 없다해도, **타입만 알고 있다면** 그 타입의 기능을 확장할 수도 있습니다. 하지만 기존 기능 오버라이딩은 불가능합니다.
- 익스텐션 타입에 추가 가능한 기능은 연산 타입/인스턴스 프로퍼티, 타입/인스턴스 메서드, 이니셜라이저 등등이 있습니다. 또한 특정 프로토콜을 준수할 수 있도록 기능을 추가할 수 있습니다.

---

## 익스텐션

- 익스텐션(Extension)은 스위프트의 강력한 기능 중 하나
- 익스텐션은 구조체, 클래스, 열거형, 프로토콜 타입에 새로운 기능을 추가할 수 있는 기능
- 기능을 추가하려는 타입의 구현된 소스 코드를 알지 못하거나 볼 수 없다해도, **타입만 알고 있다면** 그 타입의 기능을 확장할 수도 있음.
- 익스텐션은 타입에 새로운 기능을 추가할 수 있지만, 기존에 존재하는 기능을 **재정의 불가**하므로 오버라이딩은 불가능하다.

<<스위프트의 익스텐션이 타입에 추가할 수 있는 기능>>

- 연산 타입 프로퍼티 / 연산 인스턴스 프로퍼티
- 타입 메서드 / 인스턴스 메서드
- 이니셜라이저
- 서브스크립트
- 중첩 타입
- 특정 프로토콜을 준수할 수 있도록 기능 추가



---

# Extension 내부에서 함수를 override할 수 있는지 설명하시오.

- 익스텐션은 타입에 새로운 기능을 추가할 수 있지만, 기존에 존재하는 기능을 **재정의 불가**하므로 오버라이딩은 불가능합니다.
- 하지만, Objective-C와의 호환성을 위해 Objective-C 관련 함수들은 Override가 가능합니다.

---

# 접근 제어자의 종류엔 어떤게 있는지 설명하시오.

- 기능이 정의되고 구현된 범위에서만 쓸 수 있는 private, 해당 요소가 구현된 소스파일 내부에서만 사용 가능한 fileprivate, 소스파일이 속해있는 모듈 어디서든 쓰일 수 있고 기본 접근 제어자인 internal, 어디서든 쓸 수 있는 public, 가장 높은 접슨 수준으로 해당 클래스가 정의된 모듈 밖에 다른 모듈에서 상속 가능하고, 클래스와 클래스 멤버에서만 가능한 open이 있습니다.

---

### `open - 개방 접근수준`

- 개방 접근수준은 공개 접근수준 이상으로 높은 접근수준이며, 클래스와 클래스의 멤버에서만 사용할 수 있다.
- 개방 접근수준의 클래스는 그 클래스가 정의된 모듈 밖의 다른 모듈에서도 상속할 수 있다.
- 개방 접근수준의 클래스 멤버는 해당 멤버가 정의된 모듈 밖의 다른 모듈에서도 재정의할 수 있다.
- 클래스를 개방 접근수준으로 명시하는 것은 그 클래스를 다른 모듈에서도 부모클래스로 사용하겠다는 목적으로 클래스를 설계했음을 의미한다.

### `public - 공개 접근수준`

- `public` 키워드로 접근수준이 지정된 요소는 어디서든 쓰일 수 있다.
- 공개 접근수준은 주로 프레임워크에서 외부와 연결될 인터페이스를 구현하는데 많이 쓰인다.

### `internal - 내부 접근수준`

- 내부 접근수준은 기본적으로 모든 요소에 암묵적으로 지정하는 기본 접근수준이다.
- 내부 접근수준으로 지정된 요소는 소스파일이 속해 있는 모듈 어디에서든 쓰일 수 있다.
- 하지만 그 모듈을 가져다 쓰는 외부 모듈에서는 접근할 수 없다.
- 보통 외부에서 사용할 클래스나 구조체가 아니며, 모듈 내부에서 광역적으로 사용할 경우 내부 접근수준을 지정한다.
- `internal`은 기본 접근수준이므로 굳이 표기하지 않아도 된다.

### `fileprivate - 파일외부비공개 접근수준`

- 파일외부비공개 접근수준으로 지정된 요소는 그 요소가 구현된 소스파일 내부에서만 사용할 수 있다.
- 해당 소스파일 외부에서 값이 변경되거나 함수를 호출하면 부작용이 생길 수 있는 경우에 사용하면 좋다.

### `private - 비공개 접근수준`

- 비공개 접근수준은 가장 한정적인 범위이다.
- 비공개 접근수준으로 지정된 요소는 그 기능을 정의하고 구현한 범위 내에서만 사용할 수 있다.
- 비공개 접근수준으로 지정한 기능은 같은 소스파일 안에 구현한 다른 타입이나 기능에서도 사용할 수 없다.

---

# defer란 무엇인지 설명하시오.

- 블록 안에 현재 코드 블록을 나가기 전에 꼭 실행해야 할 구문을 작성한느 곳입니다. 코드가 블록을 어떻게 빠져 나가든 꼭 마무리해야 되는 작업을 할 수 있게 도와줍니다.
- defer문이  가장 먼저 블록 내에 최상단에 적혀있어도  블록을 나가기 전, 가장 마지막에 실행됩니다.

---

# 프로토콜이란 무엇인지 설명하시오.

- 프로토콜(protocol)은 특정 역할을 수행하기 위한 메서드, 프로퍼티, 기타 요구사항 등의 청사진을 정의합니다. 기능만 정의할 뿐 실제 구현은 하지 않습니다.
- 구조체, 클래스, 열거형들은 프로토콜을 채택하여 프로토콜의 요구사항을 구현할 수 있습니다.
  - 단, 프로토콜에 정의된 모든 기능을 다 구현해야 합니다.

## 프로토콜

- 프로토콜(protocol)은 특정 역할을 수행하기 위한 메서드, 프로퍼티, 기타 요구사항 등의 청사진 정의
- 구조체, 클래스, 열거형은 프로토콜을 채택(Adopted)해서 특정 기능을 수행하기 위한 프로토콜의 요구사항을 실제로 구현할 수 있음.
- 어떤 프로토콜의 요구사항을 모두 따르는 타입은 그 프로토콜을 준수한다(conform)고 표현
- 타입에서 프로토콜의 요구사항을 충족시키려면 프로토콜이 제시하는 청사진의 기능을 모두 구현해야 함.
  - 즉, 프로토콜은 기능을 정의하고 제시할 뿐, 스스로 기능 구현 X