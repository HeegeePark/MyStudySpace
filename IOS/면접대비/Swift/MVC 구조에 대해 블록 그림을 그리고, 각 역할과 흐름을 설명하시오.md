# MVC 구조에 대해 블록 그림을 그리고, 각 역할과 흐름을 설명하시오.

- 모델 = 데이터
- 뷰 = 사용자가 보는 결과 화면 
- 컨트롤러 = 사용자 입력 처리, 요청에 맞는 데이터를 모델에게 요청해서 그것을 뷰에 반영하여 사용자한테 보여줌.

BUT, ios는 view와 controller 분리가 어려움. 뷰컨트롤러가 거의 모든 일을 하게 됨.

![image](https://user-images.githubusercontent.com/47033052/222340055-a930f90d-12b0-46a7-91c4-0b1b44df9f82.png)

---

## 프로토콜

- 프로토콜(protocol)은 특정 역할을 수행하기 위한 메서드, 프로퍼티, 기타 요구사항 등의 청사진 정의
- 구조체, 클래스, 열거형은 프로토콜을 채택(Adopted)해서 특정 기능을 수행하기 위한 프로토콜의 요구사항을 실제로 구현할 수 있음.
- 어떤 프로토콜의 요구사항을 모두 따르는 타입은 그 프로토콜을 준수한다(conform)고 표현
- 타입에서 프로토콜의 요구사항을 충족시키려면 프로토콜이 제시하는 청사진의 기능을 모두 구현해야 함.
  - 즉, 프로토콜은 기능을 정의하고 제시할 뿐, 스스로 기능 구현 X

---

OOP의 핵심은 상속입니다. 상속을 통해 타입을 확장하는 수직 구조이고 IS-A 관계를 표현 할 수 있습니다. 이 과정에서 불필요한 메서드나 변수를 물려 받아야 한다는 단점이 있고 class에서만 상속이 가능합니다.

POP는 수평구조 표현인 합성으로 객체를 묘사할 수 있게 도와줍니다. 합성을 통해 타입을 확장하고 HAS-A 관계로 표현됩니다. Protocol은 불필요한 메서드나 변수를 갖지 않게 할 수 있고 class 뿐만 아니라 struct, enum에서도 사용 가능합니다.

---

# Hashable이 무엇이고, Equatable을 왜 상속해야 하는가?

`Hashable`은 프로토콜 중 하나로, `Hasher`에 의해 해시 값을 `hash`할 수 있는 타입이다. 즉, 이 프로토콜을 채택한 타입은 유일한 값(해시값)으로 구분될 수 있다는 것이다.

`Equatable`은 값의 비교가 가능함을 보장해주는 프로토콜이다. 이 프로토콜을 채택한 타입들은 `==` 연산자나 `!=` 연산자를 사용해 값을 비교할 수 있다. `Array`에서 `contains(_:)` 메소드를 사용할 수 있는 것도 `Array`가 `Equatable` 프로토콜을 채택하고 있기 때문이다.

### Equatable을 상속하는 이유

어떤 객체가 `Hashable`하다는 것은 딕셔너리의 키 값으로 사용될 수 있다는 것, 즉 *구별될 수 있는 값* 이라는 뜻이다. 그렇다면 두 객체의 해시 값이 같다면 두 객체들은 같은 객체라고 할 수 있을까?

> `a == b`이면 `a.hashvalue == b.hashvalue` 은 참이다. 그러나 그 역은 성립하지 않는다.

객체의 해시값이 같다는 사실은 두 객체가 같다는 것을 보장해주지 않는다. 따라서 `Hashable` 프로토콜은 `Equatable` 프로토콜을 상속하여 객체가 같기 위한 연산자를 정의해주는 것이다.

https://devejs.github.io/ios/2020/10/07/swift-hashable.html

---

# mutating

사전적 의미 - 변화시키다, 돌연변이

클래스는 reference 타입이고 `struct와 enum` 는 value type입니다.

값 타입의 속성은 기본적으로 인스턴스 메서드 내에서 수정할 수 없습니다.
만약 수정해야하는 경우 `mutating`을 붙여주면 됩니다.



mutating을 선언한 메서드는 메서드 내에서 프로퍼티를 변경할 수 있고, 메서드가 종료될 때 변경한 모든 내용을 원래 struct에 다시 기록합니다. 또한 메서드는 self property에 새 인스턴스를 할당할 수도 있습니다.



**mutating 키워드는 해당 메서드가 호출된다면 실제 복사를 해야한다고 알려주는 역할입니다.**

 **만약 let으로 선언된 인스턴스는 프로퍼티가 변수여도 속성을 변경할 수 없기 때문에 mutating 메서드를 호출할 수 없습니다.**

https://velog.io/@hayeon/mutating-%ED%82%A4%EC%9B%8C%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EC%8B%9C%EC%98%A4

---

## escaping closure

- 클로저가 함수 인자로 전달되지만 함수 밖에서 (함수가 반환된 후에) 실행되는거
  - 함수가 끝난 후에도 메모리에 저장돼있어야 함
  - 이는 closure 안에서 사용된 outer object (self와 같은)에 weak와 같은 레퍼런스 타입을 사용해야 할 수 있음을 주의하도록 한다.
- 매개변수 앞에 @escaping 써야함
- 비동기나 completionHandler에서 쓸 수 있음
  - 한 함수 끝나고 다음 함수 실행되도록 순서 정할 수 있으니까

### closure

- 사용자의 **코드 안에서 전달되어 사용할 수 있는 로직**을 가진 중괄호 `{}`로 구분된 **코드 블럭**

---

## 익스텐션

- 익스텐션(Extension)은 스위프트의 강력한 기능 중 하나
- 익스텐션은 구조체, 클래스, 열거형, 프로토콜 타입에 새로운 기능을 추가할 수 있는 기능
- 기능을 추가하려는 타입의 구현된 소스 코드를 알지 못하거나 볼 수 없다해도, **타입만 알고 있다면** 그 타입의 기능을 확장할 수도 있음.

<<스위프트의 익스텐션이 타입에 추가할 수 있는 기능>>

- 연산 타입 프로퍼티 / 연산 인스턴스 프로퍼티
- 타입 메서드 / 인스턴스 메서드
- 이니셜라이저
- 서브스크립트
- 중첩 타입
- 특정 프로토콜을 준수할 수 있도록 기능 추가



---

익스텐션은 타입에 새로운 기능을 추가할 수 있지만, 기존에 존재하는 기능을 **재정의 불가**하므로 오버라이딩은 불가능하다.

---

### `open - 개방 접근수준`

- 개방 접근수준은 공개 접근수준 이상으로 높은 접근수준이며, 클래스와 클래스의 멤버에서만 사용할 수 있다.
- 개방 접근수준의 클래스는 그 클래스가 정의된 모듈 밖의 다른 모듈에서도 상속할 수 있다.
- 개방 접근수준의 클래스 멤버는 해당 멤버가 정의된 모듈 밖의 다른 모듈에서도 재정의할 수 있다.
- 클래스를 개방 접근수준으로 명시하는 것은 그 클래스를 다른 모듈에서도 부모클래스로 사용하겠다는 목적으로 클래스를 설계했음을 의미한다.

### `public - 공개 접근수준`

- `public` 키워드로 접근수준이 지정된 요소는 어디서든 쓰일 수 있다.
- 공개 접근수준은 주로 프레임워크에서 외부와 연결될 인터페이스를 구현하는데 많이 쓰인다.

### `internal - 내부 접근수준`

- 내부 접근수준은 기본적으로 모든 요소에 암묵적으로 지정하는 기본 접근수준이다.
- 내부 접근수준으로 지정된 요소는 소스파일이 속해 있는 모듈 어디에서든 쓰일 수 있다.
- 하지만 그 모듈을 가져다 쓰는 외부 모듈에서는 접근할 수 없다.
- 보통 외부에서 사용할 클래스나 구조체가 아니며, 모듈 내부에서 광역적으로 사용할 경우 내부 접근수준을 지정한다.
- `internal`은 기본 접근수준이므로 굳이 표기하지 않아도 된다.

### `fileprivate - 파일외부비공개 접근수준`

- 파일외부비공개 접근수준으로 지정된 요소는 그 요소가 구현된 소스파일 내부에서만 사용할 수 있다.
- 해당 소스파일 외부에서 값이 변경되거나 함수를 호출하면 부작용이 생길 수 있는 경우에 사용하면 좋다.

### `private - 비공개 접근수준`

- 비공개 접근수준은 가장 한정적인 범위이다.
- 비공개 접근수준으로 지정된 요소는 그 기능을 정의하고 구현한 범위 내에서만 사용할 수 있다.
- 비공개 접근수준으로 지정한 기능은 같은 소스파일 안에 구현한 다른 타입이나 기능에서도 사용할 수 없다.

---

# defer란 무엇인지 설명하시오.

defer란, 현재 코드 블록을 나가기 전에 꼭 실행해야 되는 코드를 작성하여
코드가 블록을 어떻게 빠져 나가든 꼭 마무리해야 되는 작업을 할 수 있게 도와줍니다.

defer문을 가장 먼저 실행했음에도 가장 마지막에 실행된다.