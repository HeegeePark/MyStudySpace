파이프 라인 : 명령어들은 각 해당 과정의 기능에 맞는 하드웨어에 의해 수행되는데 이러한 하드웨어의 묶음으로서 명령어는 온전히 처리하게 하는 역할을 한다. 즉, 명령어를 처리할 수 있는 하드웨어의 묶음이다.

파이프 라이닝

- 명령의 처리 단계를 나누고 서로 다른 명령들을 중첩 실행 시키는 것
	- 즉, 명령어 사이클의 각 단계를 다음 단계로 전달하면서, 각 단계를 동시에 실행하도록 운영하는 기법
- 하나의 프로세서를 서로 다른 기능을 가진 다수의 서브프로세서로 나누어 동시에 서로 다는 데이터 처리
- 파이프라이닝되지 않은 프로세서는 한 명령어가 '인출 - 디코드 - 실행 - 쓰기'가 끝나기 전에는 다른 명령어가 파이프라인에 투입될 수 없다.
- 하지만 어떤 명령어가 실행 단계로 넘어왔다면 인출 및 디코드 기능을 담당하는 하드웨어가 해당 명령어와는 일이 끝났으나 끝까지 기다리는 비효율을 극복하기 위해 파이프라인을 각 단계별로 나눠, 각 단계별로 명령어를 투입하는 '파이프라이닝'이라는 기법이 도입되었다.
- 파이프라이닝되지 않은 (non-pipelined) 프로세서가 명령어를 처리할 때에는
각 명령어가 인출-디코드-실행-쓰기 과정을 완료할 때까지 다음 명령어가 기다려야 하므로
매 4사이클마다 한개의 명령어를 처리할 수 있다. 즉 이 경우의 throughput은 0.25명령어/클럭이 된다.
(※ 파이프라이닝되지 않은 프로세서의 각 작업단계를 뭉뚱그려 "거대한 하나의 파이프라인 스테이지"로 볼 수도 있고
이렇게 보면 매 클럭당 한개의 명령어가 처리되는 셈인데, 이 관점에서는 클럭 주기가 4배 길어지는 셈)


슈퍼 파이프 라이닝
- 파이프 라인들을 더욱 작게 분할하여 처리 시간 차이를 최소화.
- 어떤 동작이 실행 될 때, 그 클럭을 나누어서 다음 명령어에 대한 동작을 수행

슈퍼스칼라

- CPU 내에 여러개의 파이프 라인을 두어 명령어를 동시에 실행하는 기술

- 데이터, 자원, 프로시저 의존성을 가질때 불가능

- stall이 발생하면 동시 실행하는 명령어 수만큼 멈추기 때문에 손해가 크다.
	- 미리 프로그램을 읽어 stall이 발생할 명령어를 찾아 순서를 조절해 성능을 극대화 할 수 있는 컴파일러의 역할이 매우 중요하다.
